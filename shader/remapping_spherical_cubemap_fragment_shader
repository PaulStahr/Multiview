/*uniform sampler2D map0;
uniform sampler2D map1;
uniform sampler2D map2;
uniform sampler2D map3;
uniform sampler2D map4;
uniform sampler2D map5;*/
uniform samplerCube map;
uniform samplerCube positionMap;
uniform int viewtype;
uniform highp mat4 transform;
uniform highp mat4 tCam0;
uniform highp mat4 tCam1;
uniform highp mat4 tCam2;
uniform int numOverlays;
uniform highp float fovUnif;
varying highp vec2 texCoordV;

precision highp float;

//    VIEWTYPE_RENDERED = 0, VIEWTYPE_POSITION = 1, VIEWTYPE_DEPTH = 2, VIEWTYPE_FLOW = 3, VIEWTYPE_INDEX = 4


void main() {
    float len = length(texCoordV);
    if (len > fovUnif)
    {
        gl_FragColor = vec4(0.);
    }
    else
    {
    //TODO use cubemap-extension
        highp vec3 sphere;
        float sin = sin(len);
        sphere.xy = texCoordV.xy * (sin / len);
        sphere.z = cos(len);
        gl_FragColor = texture(map, sphere);
        if (viewtype == 0)
        {
            //if (numOverlays != 0)
            {
                highp vec4 pos = texture(positionMap, sphere);
                pos.w = 1;
                gl_FragColor.x *= float((tCam0 * pos).z < 0);
                pos.w = 1;
                gl_FragColor.y *= float((tCam1 * pos).z < 0);
            }
        }
        else if (viewtype == 1)
        {
            gl_FragColor.w = 1;
            gl_FragColor = transform * gl_FragColor;
        }
        else if (viewtype == 2)
        {
            //  float z = depth * 2.0 - 1.0; // back to NDC 
            //return (2.0 * near * far) / (far + near - z * (far - near));	
            //gl_FragColor = gl_FragColor*3. - 2.5;
            gl_FragColor.w = 1;
            gl_FragColor = length(transform * gl_FragColor);
            //gl_FragColor = length(gl_FragColor) * 0.01;
            //gl_FragColor = gl_FragColor * 10.;//TODO retransform to activate early fragment test
        }
        else if (viewtype == 3)
        {
            highp vec2 tcn = texCoordV / len;
            highp vec2 tcnr = vec2(-tcn.y, tcn.x);
            highp float dr = dot(tcn, gl_FragColor.xy) * sphere.z + sin*gl_FragColor.z;
            //highp float dr = dot(vec2(dot(tcn, gl_FragColor.xy), gl_FragColor.z), vec2(cos, sin));
            highp float da = dot(tcnr, gl_FragColor.xy);
            gl_FragColor.xy = 157*(tcn * vec2(dr) + tcnr * vec2(da));
            gl_FragColor.x = -gl_FragColor.x; //Swap sign to match blender coordinate system
            gl_FragColor.z = 0;
            
            /*
            float sinlenq = sin * len * len;
            float cosls = cos * len - sin;
            
            highp vec3 v0, v1;
            v1.y=cosls * texCoordV.y*texCoordV.y + sinlenq;
            v0.x=cosls * texCoordV.x*texCoordV.x + sinlenq;
            
            v1.x = v0.y = texCoordV.x*texCoordV.y*cosls;
            
            v0.z =sinlenq * texCoordV.x;
            v1.z =sinlenq * texCoordV.y;*/
            
            /*float green   = dot(gl_FragColor.xyz, v0) / length(v0);
            float red     = dot(gl_FragColor.xyz, v1) / length(v1);

            gl_FragColor.x = -100.0*green;
            gl_FragColor.y = 100.0*red;
            gl_FragColor.z = 0.0;*/
        }
    }
}

//div = sqrt(c*c*xq*lenq + yq*sin*sin)
        /*(xq*cosc - xq*sin / len + len*sin)/div
        x*y*(cosc - sin / len)/div
        -c*x*sin/div*/
