#version 130

#if __VERSION__ < 130
#define TEXTURE2D texture2D
#else
#define TEXTURE2D texture
#endif

uniform samplerCube map;
uniform samplerCube positionMap;
uniform int viewtype;
uniform highp mat4 transform;
uniform highp mat4 transformColor;
uniform highp mat4 tCam0;
uniform samplerCube positionMap0;
uniform highp mat4 tCam1;
uniform samplerCube positionMap1;
uniform highp mat4 tCam2;
uniform samplerCube positionMap2;
uniform int numOverlays;
uniform highp float fovUnif;
varying highp vec2 texCoordV;

//precision highp float;

//    VIEWTYPE_RENDERED = 0, VIEWTYPE_POSITION = 1, VIEWTYPE_DEPTH = 2, VIEWTYPE_FLOW = 3, VIEWTYPE_INDEX = 4


void main() {
    highp float len = length(texCoordV);
    if (len > fovUnif)
    {
        discard;
    }
    highp vec3 sphere;
    highp float sin = sin(len);
    sphere.xy = texCoordV.xy * (sin / len);
    sphere.z = cos(len);
    gl_FragColor = texture(map, sphere);
    if (viewtype == 0)
    {
        if (numOverlays != 0)
        {
            highp vec4 pos = texture(positionMap, sphere);
            highp float lambda = 1.05;
            pos.w = 1.;
            {
                highp vec3 posCam = vec3(tCam0 * pos);
                posCam.z = -posCam.z;//Why invert z?
                highp vec4 tPosCam = texture(positionMap0, posCam);
                tPosCam.w = 1.;
                gl_FragColor.x *= 0.5 + 0.5 * float((posCam).z > 0 && length((tCam0 * tPosCam).xyz) * lambda > length(posCam));
            }
            if (numOverlays > 1)
            {
                {
                    highp vec3 posCam = vec3(tCam1 * pos);
                    posCam.z = -posCam.z;
                    highp vec4 tPosCam = texture(positionMap1, posCam);
                    tPosCam.w = 1.;
                    gl_FragColor.y *= 0.5 + 0.5 * float((posCam).z > 0 && length((tCam1 * tPosCam).xyz) * lambda > length(posCam));
                }
            
                if (numOverlays > 2)
                {
                    highp vec3 posCam = vec3(tCam2 * pos);
                    posCam.z = -posCam.z;
                    highp vec4 tPosCam = texture(positionMap2, posCam);
                    tPosCam.w = 1.;
                    gl_FragColor.z *= 0.5 + 0.5 * float((posCam).z > 0 && length((tCam2 * tPosCam).xyz) * lambda > length(posCam));
                }
            }
        
        }
    }
    else if (viewtype == 1)
    {
        gl_FragColor.w = 1;
        gl_FragColor = transform * gl_FragColor;
    }
    else if (viewtype == 2)
    {
        //  float z = depth * 2.0 - 1.0; // back to NDC 
        //return (2.0 * near * far) / (far + near - z * (far - near));	
        //gl_FragColor = gl_FragColor*3. - 2.5;
        gl_FragColor.w = 1;
        gl_FragColor.xyzw = vec4(length(transform * gl_FragColor));
    }
    else if (viewtype == 3)
    {
        highp mat2 tcn = mat2(texCoordV, vec2(-texCoordV.y, texCoordV.x));
        tcn /= len;
        highp vec2 ds = gl_FragColor.xy * tcn;
        ds.x = ds.x * sphere.z + sin*gl_FragColor.z;
        gl_FragColor.z = dot(sphere,gl_FragColor.xyz);
        gl_FragColor.xy = tcn * ds;
        
        /*highp vec2 tcn = texCoordV / len;
        highp vec2 tcnr = vec2(-tcn.y, tcn.x);
        highp float dr = dot(tcn, gl_FragColor.xy) * sphere.z + sin*gl_FragColor.z;
        highp float da = dot(tcnr, gl_FragColor.xy);
        gl_FragColor.z = dot(sphere,gl_FragColor.xyz) * 157;
        gl_FragColor.xy = 157*(tcn * vec2(dr) + tcnr * vec2(da));
        gl_FragColor.x = -gl_FragColor.x; //Swap sign to match blender coordinate system
        */
    }
    else if (viewtype == 4)
    {
        gl_FragColor.xyz = gl_FragColor.xxx;
    }
    gl_FragColor = transformColor * gl_FragColor;
    //gl_FragColor.x = 1;
};

//div = sqrt(c*c*xq*lenq + yq*sin*sin)
        /*(xq*cosc - xq*sin / len + len*sin)/div
        x*y*(cosc - sin / len)/div
        -c*x*sin/div*/
